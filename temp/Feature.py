from nltk.corpus import namesfrom nltk.corpus import stopwordsmale = [name for name in names.words("male.txt")]female = [name for name in names.words("female.txt")]class Mention(object):    def __init__(self,tokens,sentenceID,span,label):        self.tokens = tokens        self.sentenceID = sentenceID        self.span = span        self.label = label        self.feat = None    def features(self):        #get unary features        f = {}        f['text'] = ' '.join([t.annotations['Word itself'] for t in self.tokens])        f['NE'] = self.tokens[0].annotations['Named Entities'].strip('(*)')        f['definite'] = 1 if self.tokens[0].text.lower() == 'the' else 0        f['demonstrative'] = 1 if self.tokens[0].text.lower() in {'this', 'that', 'these', 'those'} else 0        f['pronoun'] = self.is_pronoun()        f['semClass'] = self.sem_class(f['pronoun'],f['NE'])        f['gender'] = self.gender(f['pronoun'],f['text'])        self.feat = f    def get_features(self):        if not self.feat:            self.features()        return self.feat    def sem_class(self,is_pronoun,NE):        if is_pronoun:            word = self.tokens[0].annotations['Word itself'].lower()            if word in {'he','she','you','i','me','her','him','his','hers','mine','us','ours','we'}:                return 1            if word in {'it','its'}:                return 0            if word in {'them','they','their'}:                return 2        else:            if NE in {'NORP','PERSON'}:                return 1            if NE in {'TIME','GPE','ORG','CARDINAL','LOC','QUANTITY','DATE','FAC'}:                return 0            else:                return 2        return 2    def is_pronoun(self):        if len(self.tokens) == 1:            if self.tokens[0].annotations['POS'].startswith('PRP'):                return 1        return 0    def gender(self,is_pronoun,text):        if is_pronoun:            word = self.tokens[0].annotations['Word itself'].lower()            if word in {'he','him','his'}:                return 0            if word in {'she','her','hers'}:                return 1            else:                return 2        else:            for t in text.split():                if t in male:                    return 0                elif t in female:                    return 1                else:                    return 2        return 2    def write_results(self,clusterID):        self.tokens[0].predicted_coref['start'].add(clusterID)        self.tokens[-1].predicted_coref['end'].add(clusterID)class MentionPair(object):    def __init__(self,antecedent,anaphor):        self.antecedent = antecedent        self.anaphor = anaphor        if antecedent.label==anaphor.label:            self.label = True        else:            self.label = False    def features(self):        antecedent_features = self.antecedent.get_features()        anaphor_features = self.anaphor.get_features()        f = {'antecedent_'+x:antecedent_features[x] for x in antecedent_features if x != 'text' and antecedent_features[x] != None}        for x in anaphor_features:            if x != 'text' and anaphor_features[x]!= None:                f['anaphor_'+x] = anaphor_features[x]        #get binary features        f['text_match'] = 1 if antecedent_features['text'] == anaphor_features['text'] else 0        if f['antecedent_semClass'] == 2 or f['anaphor_semClass'] == 2:            f['semClass_match'] = 2        else:            f['semClass_match'] = 1 if f['antecedent_semClass'] == f['anaphor_semClass'] else 0        f['distance'] = self.anaphor.sentenceID - self.antecedent.sentenceID        if f['antecedent_gender'] == 2 or f['anaphor_gender'] == 2:            f['gender_match'] = 2        else:            f['gender_match'] = 1 if f['antecedent_gender'] == f['anaphor_gender'] else 0        f1 = {'distance': f['distance'], 'text_match':f['text_match'],'gender_match':f['gender_match'],'antecedent_pronoun':f['antecedent_pronoun'],'anaphor_pronoun':f['anaphor_pronoun']}        return f1